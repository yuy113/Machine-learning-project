//#include <Rcpp.h>
#include <iostream>
#include <RcppArmadillo.h>
// [[Rcpp::depends("RcppArmadillo")]]
using namespace Rcpp;
using namespace arma;



//the function-gradloglikphidni
//the gradient function of the particle ELBO for the P vector phi_pdni,p=1,2,...,P
//input 1,x_pndi=logit(phi_pndi) P-vector,n=1,2,...,N_d the number of words in the document-d
//d=1,2,...,D, the number of the documents,i=1,2,...,k-1 corresponds the number of free parameters
//phi_pndi the probability the nth word in dth document is generated by latent topic i
//i=1,2,...k, the k latent topics in LDA model for the constraints
//input 2:importance weights-omega_p,p=1,2,...,P, with sum of omega_p equal to 1
//and each omega_p is between 0 and 1
//input 3, gamma_di,i=1,2,...k,d=1,2,...,D
//input 4: beta_ivdn,v_dn, unique length of the word w_dn,
//i=1,2,...,k,j=1,2,...,V where given any i, sum of beta_ij over j from 1 to V equal to 1
//input 5, lambda-the particle entropy parameter
//output: the gradient of log likelihood function for the P vector-phi_pndi
// phi_pndi between 0 and 1 
// [[Rcpp::export]]
NumericVector gradloglikxdni(NumericVector xndi, NumericVector omega,
  NumericVector gammadi,double betaivdn,double lambda,IntegerVector indexndi){
  if(xndi.size() != omega.size()) stop("two inputs should have the length!");
   if(indexndi.size() != 3) stop("index vector should have the length 3!");
  int P=xndi.size(),k=gammadi.size(),i,j,m=indexndi[3];
  double sumomegatemp=0.0,sumgammadi=0.0,sumomegax=0.0;
  NumericVector Dxndi(0.0,P);
  for (i=0;i < P;i++){
     sumomegatemp+=omega[i];
     sumgammadi+=gammadi[i];
     sumomegax+=omega[i]/(1+std::exp(-xndi[i]));
  }
  for (j=0;j < k;j++){
     
     sumgammadi+=gammadi[j];
     
  }

   
  if(sumomegatemp!= 1.0) stop("the input omega vector is wrong!");
   for (i=0;i<P;i++){
     Dxndi[i]=(omega[i]*(R::digamma(gammadi[m])-R::digamma(sumgammadi))
     +omega[i]*std::log(betaivdn)-lambda*omega[i]*(std::log(sumomegax)+1))*(std::exp(xndi[i])/std::pow(1+std::exp(xndi[i]),2));
  }
 return Dxndi;
}

// [[Rcpp::export]]
double invlogistic(double x){
   double invlogisticx=std::exp(x)/(1+std::exp(x));
  return invlogisticx;
}

// [[Rcpp::export]]
double gradinvlogistic(double x){
   double gradinvlogisticx=std::exp(x)/(std::pow(1+std::exp(x),2.0));
   return gradinvlogisticx;
}

//the function-hessianphidni
//the Hessian matrix function of the particle ELBO for the P vector phi_pdni,p=1,2,...,P
//input 1,P,n=1,2,...,N_d the number of words in the document-d
//d=1,2,...,D, the number of the documents
//phi_pndi the probability the nth word in dth document is generated by latent topic i
//i=1,2,...k, the k latent topics in LDA model
//input 2:importance weights-omega_p,p=1,2,...,P, with sum of omega_p equal to 1
//and each omega_p is between 0 and 1
//input 3, lambda-the particle entropy parameter
//output: the PxP Hessian matrix of the particle ELBO for the P vector-x_pndi
// phi_pndi between 0 and 1 
// [[Rcpp::export]]
NumericMatrix hessianxdni(NumericVector xndi, NumericVector omega,
  NumericVector gammadi,double betaivdn,double lambda,IntegerVector indexndi,
  Function gradloglikxdni,Function invlogistic, Function gradinvlogistic){
   if(xndi.size() != omega.size()) stop("two inputs should have the same length!");
   if(indexndi.size() != 3) stop("index vector should have length 3!");
  int P=xndi.size(),k=gammadi.size(),i;
  double sumomegatemp=0.0,sumomegax=0.0;
  NumericMatrix Hessianx(P,P);
  NumericVector gradx=gradloglikxdni(xndi, omega, gammadi, betaivnd, lambda,indexndi);
  for (i=0;i < P;i++){
     sumomegatemp+=omega[i];
     double invlogisticxi=invlogistic(xndi[i]);
     sumomegax+=omega[i]*invlogisticxi;
  }
  if(sumomegatemp!= 1.0) stop("the input omega vector is wrong!");
  for (i=0;i < P;i++){
      double gradxi=gradinvlogistic(xndi[i]);
      double invlogisticxi=invlogistic(xndi[i]);
      Hessianx(i,i)=gradx[i]*(1-invlogisticxi)*gradxi -lambda*omega[i]*omega[i]/sumomegax*std::pow(gradxi,2.0);
    }
  
   for (i=0; i < (P-1);i++){
     for (j=(i+1); j < P; j++){
    
           double gradxi=gradinvlogistic(xndi[i]);
           double gradxj=gradinvlogistic(xndi[j]);
           Hessianx(i,j)=-lambda*omega[i]*omega[j]*gradxi*gradxj/sumomegax;

         }

     }

   for (j=0; j < (P-1);j++){
     for (i=(j+1); i < P; i++){
    
           Hessianx(i,j)=Hessianx(j,i);

         }

     }

  return Hessianx;

}

//the function-newtonraphsonphidni
// multivariate Newton-Raphson method to derive the solution for x_pdni=logit(phi_pdni),
//for p=1,2,...,P where P is the number of the predefined particles
//n=1,2,...,N_d the number of words in the document-d
//d=1,2,...,D, the number of the documents
//phi_pndi the probability the nth word in dth document is generated by latent topic i
//i=1,2,...k, the k latent topics in LDA model
//input 1:maxInter, the maximum number of iterations for the multivariate Newton-Raphson method
//input 2:maxTol, a small number to check the convergence of iteration equation,default 10^-10
//and each omega_p is between 0 and 1
//input 3, function-gradloglikphidni, the gradient vector of the particle ELBO for the P vector-phi_pndi
//input 4: function hessianphidni-PxP Hessian matrix of the particle ELBO for the P vector-phi_pndi
//input 5:importance weights-omega_p,p=1,2,...,P, with sum of omega_p equal to 1
//and each omega_p is between 0 and 1
//input 6, gamma_di,i=1,2,...k,d=1,2,...,D
//input 7: beta_ij,i=1,2,...,k,j=1,2,...,V where given any i, sum of beta_ij over j from 1 to V equal to 1
//input 8, lambda-the particle entropy parameter
//inp
//output: the P vector the solution for gradient vector of the particle ELBO for the P vector-phi_pndi
// [[Rcpp::export]]
NumericVector newtonraphsonxdni(NumericVector omega,NumericVector gammadi,double betaivnd,
  double lambda,int maxInter,double maxTol,IntegerVector indexndi,Function gradloglikphidni,Function hessianphidni){
      if(indexndi.size() != 3) stop("index vector should have length 3!");
     int P=omega.size(),i;
     //initialization of P vector-phipndi_init
     arma::colvec phipphi_init=arma::randu(P);
     NumericVector phindi_init=Rcpp::NumericVector(phipphi_init.begin(), phipphi_init.end());
     NumericVector xndi_init(P);
     for (i=0;i < P;i++){
       xndi_init[i]=100*(phindi_init[i]-0.5)
    }
     //change the constrained optimization to unconstrained optimization
      NumericMatrix hessianxold=hessianxdni(xndi_init,omega, gammadi, betaivnd,lambda,indexndi,gradloglikxdni);
      NumericVector gradxpndiold=gradloglikxdni(xndi_init,omega,gammadi,betaivnd,lambda,indexndi);
      arma::mat Hold(hessianxold.begin(), P, P, false);
      arma::colvec gradxold(gradxpndiold.begin(), gradxpndiold.size(), false);
      arma::colvec xold(xpndi_init.begin(), xndi_init.size(), false);
      arma::colvec xnew=xold-arma::pinv(Hold)*gradxold;
      int niter=1;
      while (arma::max(arma::abs(xnew-xold))>maxTol && niter<=maxInter){
        arma::colvec xold=xnew;
        NumericVector xpndi_old2=Rcpp::NumericVector(xold.begin(), xold.end());
        NumericMatrix hessianxold=hessianphidni(xpndi_old2,omega,lambda);
        NumericVector gradxpndiold=gradloglikphidni(xpndi_old2,omega,gammadi,betaivd,lambda);
        arma::mat Hold(hessianxold.begin(), P, P, false);
        arma::colvec gradxold(gradxpndiold.begin(), gradxpndiold.size(), false);
        arma::colvec xnew=xold-arma::pinv(Hold)*gradxold;
        niter++;}
      NumericVector xfinal=Rcpp::NumericVector(xnew.begin(), xnew.end());
      return xfinal;
      }

//update each of the possible, n=1,2,...,N_d,d=1,2,...,D,phi_pndi
//for all p=1,2,...,P,i=1,2,...,k
//for each fixed p,n,d, sum of phi_pndi over i=1,...,k equal to 1
//given gammaid,i=1,2,...,k,d=1,2,...D
//given beta_ivdn,i=1,2,...,k,v_dn=one of 1,2,...,V where given any i, sum of beta_ij over j from 1 to V equal to 1
//for all n=1,2,...,N_d,d=1,2,...,D
//given importance weights-omega1,omega2,...,omegaP
//given particle entropy tuning parameter-lambda
//given the number of particles-P implicitly provided by the length of omega vector
//given index for nd-indexnd,n=1,2,...,N_d,d=1,2,...,D
//output, P by k matrix, each row sum to 1, totally sum of N_d over d=1,2,...,D output matrix
//
NumericMatrix updateallphipi(NumericVector omega,NumericVector gammadi,NumericVector betavnd,
  double lambda,int maxInter,double maxTol,IntegerVector indexnd,Function newtonraphsonxdni,Function invlogistic){
     if(indexnd.size() != 2) stop("index vector should have length 2!");
     int P=omega.size(),k=gammadi.size(),i,j;
     NumericMatrix xdn(P,k),phidn(P,k);
     IntegerVector indexndi(3);
      indexndi[1]=indexnd[1];
      indexndi[2]=indexnd[2];
     for (i=0,i < k, i++){
      
      indexndi[3]=i;
      xdn(_,i)=newtonraphsonxdni(omega, gammadi, betaivnd,
  double lambda,int maxInter,double maxTol,IntegerVector indexndi, gradloglikphidni, hessianphidni);
     }
     NumericVector psuminvlogisticxdn(P);
     std::fill(psuminvlogisticxdn.begin(),psuminvlogisticxdn.end(),0.0);
     for (j=0,j < P, j++){
      for (i=0,i < k, i++){
         psuminvlogisticxdn[j]+=invlogistic(xdn(j,i));
      }
    }

   for (j=0,j < P, j++){
     for (i=0,i < k, i++){

        phidn(j,i)=invlogistic(xdn(j,i))/psuminvlogisticxdn[j];
      }
    }


    return phidn;

  }

  





/*** R
P<-10
omega<-rep(1/P,P)
betaivd<-0.4
lambda<-5
gammadi<-rep(1,P)
newtonraphsonphidni(omega,gammadi,betaivd,lambda,maxInter=100000,maxTol=1e-10,Function gradloglikphidni,Function hessianphidni)
*/