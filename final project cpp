#include <Rcpp.h>
#include <math.h>  
#include <boost/math/special_functions/digamma.hpp>
#include <iostream>
#include <armadillo>
using namespace std;
using namespace arma;
using namespace Rcpp;


//the function-gradloglikphidni
//the gradient function of the particle ELBO for the P vector phi_pdni,p=1,2,...,P
//input 1,P,n=1,2,...,N_d the number of words in the document-d
//d=1,2,...,D, the number of the documents
//phi_pndi the probability the nth word in dth document is generated by latent topic i
//i=1,2,...k, the k latent topics in LDA model
//input 2:importance weights-omega_p,p=1,2,...,P, with sum of omega_p equal to 1
//and each omega_p is between 0 and 1
//input 3, gamma_di,i=1,2,...k,d=1,2,...,D
//input 4: beta_iv_d
//input 5, lambda-the particle entropy parameter
//output: the gradient of log likelihood function for the P vector-phi_pndi
// phi_pndi between 0 and 1 
// [[Rcpp::export]]
NumericVector gradloglikphidni(NumericVector phindi, NumericVector omega,NumericVector gammadi,double betaivd,double lambda){
  int P=phindi.size(),i,j;
  double sumomegatemp=0.0,sumgammadi=0.0,sumomegaphi=0.0;
  NumericVector Dphindi(0.0,P);
  for (i=0,i<P,i++){
     sumomegatemp+=omega[i];
     sumgammadi+=gammadi[i];
     sumomegaphi+=omega[i]*phindi[i];
  }
  if(sumomegatemp!= 1)
    throw("the input omega vector is wrong!");
   for (i=0,i<P,i++){
     Dphindi[i]=omega[i]*(Maths::Special::Gamma::psi(gammadi[i])-Maths::Special::Gamma::psi(sumgammadi))
     +omega[i]*log(betaivd)-lambda*omega[i]*(log(sumomegaphi)+1);
  }
 return Dphindi;
}

//the function-hessianphidni
//the Hessian matrix function of the particle ELBO for the P vector phi_pdni,p=1,2,...,P
//input 1,P,n=1,2,...,N_d the number of words in the document-d
//d=1,2,...,D, the number of the documents
//phi_pndi the probability the nth word in dth document is generated by latent topic i
//i=1,2,...k, the k latent topics in LDA model
//input 2:importance weights-omega_p,p=1,2,...,P, with sum of omega_p equal to 1
//and each omega_p is between 0 and 1
//input 3, lambda-the particle entropy parameter
//output: the PxP Hessian matrix of the particle ELBO for the P vector-phi_pndi
// phi_pndi between 0 and 1 
// [[Rcpp::export]]
NumericMatrix hessianphidni(NumericVector phindi, NumericVector omega,double lambda){
  int P=phindi.size(),i,j;
  double sumomegatemp=0.0,sumgammadi=0.0,sumomegaphi=0.0;
  NumericMatrix Hessianphi=zeros(P,P);
  for (i=0,i<P,i++){
     sumomegatemp+=omega[i];
     sumomegaphi+=omega[i]*phindi[i];
  }
  if(sumomegatemp!= 1)
    throw("the input omega vector is wrong!");
  for (i=0,i<P,i++){
    for (j=0,i<P,i++){
      Hessianphi[i,j]=-lambda*omega[i]*omega[j]/sumomegaphi;
    }
  }
  
  return Hessianphi;

}

//the function-newtonraphsonphidni
// multivariate Newton-Raphson method to derive the solution for phi_pdni,
//for p=1,2,...,P where P is the number of the predefined particles
//n=1,2,...,N_d the number of words in the document-d
//d=1,2,...,D, the number of the documents
//phi_pndi the probability the nth word in dth document is generated by latent topic i
//i=1,2,...k, the k latent topics in LDA model
//input 1:maxInter, the maximum number of iterations for the multivariate Newton-Raphson method
//input 2:maxTol, a small number to check the convergence of iteration equation,default 10^-10
//and each omega_p is between 0 and 1
//input 3, function-gradloglikphidni, the gradient vector of the particle ELBO for the P vector-phi_pndi
//input 4: function hessianphidni-PxP Hessian matrix of the particle ELBO for the P vector-phi_pndi
//input 5:importance weights-omega_p,p=1,2,...,P, with sum of omega_p equal to 1
//and each omega_p is between 0 and 1
//input 6, gamma_di,i=1,2,...k,d=1,2,...,D
//input 7: beta_iv_d
//input 8, lambda-the particle entropy parameter
//inp
//output: the P vector the solution for gradient vector of the particle ELBO for the P vector-phi_pndi
// [[Rcpp::export]]
NumericVector newtonraphsonphidni(NumericVector omega,NumericVector gammadi,double betaivd,
  double lambda,int maxInter,double maxTol,Function gradloglikphidni,Function hessianphidni){
     int P=omega.size();
     //initialization of P vector-phipndi_init
     NumericVector phipndi_init=R::runif(P,0.0,1.0);
     //change the constrained optimization to unconstrained optimization
      NumericMatrix hessianphiold=hessianphidni(phipndi_init,omega,lambda);
      NumericVector gradphipndiold=gradloglikphidni(phipndi_init,omega,gammadi,betaivd,lambda);
      arma::mat Hold(hessianphiold.begin(), P, P, false);
      arma::colvec gradphiold(gradphipndiold.begin(), gradphipndiold.size(), false);
      arma::colvec phiold(phipndi_init.begin(), phipndi_init.size(), false);
      phinew=phiold-arma::pinv(Hold)*gradphiold;
      int niter=1;
      while (arma::max(arma::abs(phindinew-phiold))>maxTol && niter<=maxInter){
        phiold=phinew;
        NumericMatrix hessianphiold=hessianphidni(phiold,omega,lambda);
        NumericVector gradphipndiold=gradloglikphidni(phiold,omega,gammadi,betaivd,lambda);
        arma::mat Hold(hessianphiold.begin(), P, P, false);
        arma::colvec gradphiold(gradphipndiold.begin(), gradphipndiold.size(), false);
        phinew=phiold-arma::pinv(Hold)*gradphiold;
        niter++;}
      return phinew;
      }

/*** R
P<-10
omega<-rep(1/P,P)
betaivd<-0.4
lambda<-5
newtonraphsonphidni(omega,gammadi,betaivd,lambda,maxInter=100000,maxTol=1e-10)
*/